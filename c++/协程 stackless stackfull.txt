 
协程（coroutine）和例程（routine）
在讨论协程时，往往把这个概念和例程做对比。例程就是我们通常意义下的函数。

例程和协程的区别在于：当调用者调用被调用者时，如果是例程，只有当被调用者执行完毕后才能返回调用者；
如果是协程，被调用者可以执行到一半就挂起并返回到调用者，同时，被调用者可以再次从挂起的地方重新执行。

把协程和例程看作一个类
为了更好的理解协程和例程，基于面向对象的思想，我们把协程和例程都看作一个类。
例如，一个例程可以是做一个类F（事实上，就像仿函数那样），每次执行函数可以理解为：

F f;
f.run();

也就是说，每次执行函数，都相当于定义一个类的实例并执行它。
基于我们上面讨论的区别，对于例程而言，只有当被调用者执行完毕后才能返回调用者。
所以当f执行完成后就自动销毁了，不存在任何中间状态，f这个实例的状态不会影响执行结果。
所以，对于例程而言，run()函数是一个静态成员函数，可以直接写作F::run()。
但是对于协程而言，一个协程可以执行到一半就返回调用者，下次再继续执行，也就是说，可以：

F f;
f.run();
f.run();

F定义了多少个返回点f就可以run多少次，每次run完之后都必须保存一个中间状态。
所以，为了保存中间状态，我们把协程看作一个类并把中间状态保存到它的当前实例中，这时的run()不再是静态成员函数。


例程和协程的类中有哪些成员变量？
类总是有成员变量的，如果我们把例程和协程看作一个类，那么，它们有哪些成员变量呢？
首先，这些成员变量的值必须要能完整的记录例程/协程的当前状态。
不管是一个例程还是一个协程，在执行过程中，总是会维护一个栈，所有局部变量都会保存在栈中。
也就是说，只要记住当前栈和当前例程/协程执行到哪一行，就足够描述整个例程/协程的状态了。

有栈协程（stackfull）和无栈协程（stackless）
协程通常有两种实现方案，有栈协程和无栈协程。有栈协程的实现很好理解，每一个协程都维护一个自己的栈即可。
但是，在协程的执行过程中，栈的大小是不确定的，如果我们给每个栈分配固定大小的栈。那么，如果分配的栈太小，存在爆栈的风险；
如果分配的栈太大，就会对空间造成浪费。基于这个原因，出现了名为共享栈的处理方案。每当协程执行时，就使用共享栈；
当这个协程被挂起时，就在堆中分配内存，将当前共享栈复制过去。这样，栈的大小就不固定，可以节约很多空间。下次重新执行时再把栈复制回共享栈即可。


但是，如果使用共享栈，栈的复制需要一定的时间，频繁的切换协程会浪费大量协程。为了解决这一问题，又提出了无栈协程。那么，怎么理解无栈协程呢？

首先要知道的一点是：

对于一个例程/协程，之所以使用栈这个数据结构来保存状态，是因为当它递归调用时，可能会产生数量无限的局部变量，因此，只能用栈来保存这些局部变量。
但是，如果禁止例程/协程去调用其它例程/协程，这时对应栈的大小是固定。
栈的大小是固定的，协程的成员变量所占据的空间大小也是固定的，这时，我们可以简单的把这个协程类视作一个struct。


当然，例程/协程总是要调用其它例程/协程的。但是，我们又知道，一个例程/协程执行完毕后会清空自己的栈。
也就是说，只要我们禁止协程在子例程/子协程中返回，那么就可以简单的把协程看作一个struct，而不用浪费空间专门去存一个栈，
这就是无栈协程。当然，在无栈协程执行的过程中，它依旧需要一个栈，这时直接借用原有的栈即可，反正无栈协程只有当栈为空时才能挂起，
不会造成别的影响。不过，把协程视作一个struct并禁止无栈协程在子例程/子协程中返回很难，所以无栈协程的实现一般需要编译器的支持。
 